

# Java虚拟机原理

## 前言

>众多的编程语言中，需要特别注意Java语言，不仅仅因为它在工业界使用众多，还有其附属产生的相关技术设计非常经典。
>
>当然，所有的技术产生是有原因的，可将其归结为需求的变更，不同的环境提出不同的需求，就需要新的方案，而需要的场景越来越多，就可将其抽象为新技术！



## 正文

>正文，从最基本的编程语言出发，了解JVM的组成，进而扩展到Java应用程序的运行，为保证效率与安全，必然会有线程安全与垃圾回收机制，介绍典型的垃圾回收器及其工作原理，举例展示JVM相关配置，描述Web容器与操作系统，JVM之间的关系。

### 一、Java语言

- Java是一种**跨平台**的语言
- java开发出来的程序经过编译后，
- 可以在Linux上运行
  - 可以在windows上运行
  - 可以在PC
  - 服务器上运行
  - 也可以在手机上运行
  - 可以在X86CPU上运行
  - 可以在ARM的CPU上运行
- 不同操作系统，不同CPU 架构，不可能执行相同的指令
- java编译出来的字节码，不是直接在底层的系统平台上运行，而是在java虚拟机JVM上运行
- JVM屏蔽了底层操作系统的不同，为java字节码提供了一个统一的运行环境





### 二、JVM的组成构造

- JVM本质是一个应用程序，启动以后加载java字节码文件
- **JVM全称java Virtual Machine**
- JVM主要由类加载器，运行时数据区，执行引擎组成
- 运行时数据区主要包括**方法区，堆，java栈，程序计数寄存器**
  - 方法区，存放从磁盘加载进来的类字节码
  - 堆，存放程序运行过程中创建的类实例
  - JVM以线程为单位运行，每一个线程都有自己的java栈，栈中存放方法运行期的局部变量
  - 程序计数寄存器，保存当前线程执行到哪一行字节码指令信息
- JVM进入启动类的main方法的时候，会创建一个**主线程**，main方法的代码会被执行
- JVM封装了一组自定义的字节码指令集，有自己的程序计数器和执行引擎，像CPU一样，可以执行运算指令
- JVM像操作系统一样，有自己的程序计数器和执行机制，内存管理机制，线程和栈管理机制

![java jvm组成](4-Java虚拟机原理.assets/java jvm组成.png)





### 三、典型Java应用程序运行过程

- java命令启动JVM
- JVM的类加载器，根据java命令参数，到指定路径加载.class类文件
- 类文件被加载到内存后，存放在专门的方法区
- JVM创建一个主线程执行，这个类文件的main方法
- main方法的输入参数和方法局部变量被放入java栈
- 如果在方法内，创建了一个对象实例，这个实例信息，会被放到堆里面，而对象实例的引用（堆中的地址信息），会被纪录在栈中
- 堆中纪录的主要信息是成员变量信息
- 程序计数寄存器，初始值为main方法的第一行代码位置
- JVM的执行引擎，根据程序计数寄存器位置，去方法区加载对应代码指令
- 如果main方法，内部调用其他方法，会在java栈中创建一个新的栈帧，当前线程在方法内执行的局部变量，也在这个栈帧中
- 当方法执行结束后，这个栈帧从java栈中出栈，当前栈帧又变成main方法栈帧，继续执行main方法
- 由于java栈的作用，保证了不同方法之间，定义相同的局部变量，也不会发生混乱

![Java栈](4-Java虚拟机原理.assets/Java栈.png)





### 四、Java线程安全

- 在java线程栈中，由于天然的隔离性，成员变量是线程安全的
- 如果在方法中创建了一个对象示例，这个对象实例，没有被方法返回，或者放入某些外部对象容器的话，也是线程安全的（这个对象的引用， 没有离开方法）
- 像Servlet这样的类，在Web容器创建出来以后，会被传递给每一个访问Web应用的用户线程，这就不是线程安全的
- 如果Servlet类中没有成员变量，即使多线程同时执行，也是线程安全的，这种对象被称为**无状态对象**
  - 无状态的对象，不记录状态的对象，执行该对象任何方法不会改变对象的状态，是线程安全的
  - Web开发中常见的**Service类**，DAO类都被设计为无状态的对象，即使Web应用天然是多线程，也不需要考虑线程安全





### 五、JVM的垃圾回收机制

- 自动垃圾回收是将JVM堆中的已经不再被使用的**对象清理掉**，释放内存资源
- JVM通过一种**可达性分析算法**进行垃圾对象的识别
  - 识别过程：从线程栈帧中的局部变量，或方法区的静态变量出发，将这些变量的引用对象进行标记，然后看这些被标记的对象是否引用了其他对象，继续进行标记，所有被标记过的对象都是被使用的对象，而那些没有被标记的对象就是可以回收的对象了
  - 可达性分析算法，其实是一个引用标记算法 
- 垃圾回收有三种方法
- **清理**
  - JVM并不会真的将垃圾内存进行清理，而是将这些垃圾对象占用的内存空间**标记为空闲**，记录在一个空闲的列表中
  - 当需要创建新对象的时候，从空闲列表中找一段空闲内存分配给新对象
  - 由于标记的垃圾对象，散落在内存的空间中，标记出来的**空闲空间并不是连续的**，无法直接分配给一个很大的内存对象
- **压缩**
  - 从堆对象的头部开始，将存活的对象**拷贝**放在一段连续的内存空间中
  - 其余的空间就是连续的空间
- **复制**
  - 将堆空间分成两部分
  - 只在一部分创建对象，当该部分空间用完的时候，将标记过的可用对象复制到另一个空间中
  - JVM将这两个空间命名为**from区域，to区域**
  - 当对象从from区域复制到to区域之后，两个区域交换名称引用，继续重复from创建，复制到to区域步骤
- **分代回收**
  - 绝对多数的java对象存活时间都非常的短
  - 一般在一个方法内创建对象，对象的引用放到栈中，方法调用后，栈帧出栈，这个对象就失去了引用，称为垃圾
  - JVM将堆空间分为**新生代（young）和老年代（old）**两个区域
  - 创建对象的时候，只在新生代创建，当新生代空间不足的时候，只对新生代进行垃圾回收，需要处理的内存空间变小，回收速度加快
  - **新生代分为Eden区，From区，To区**，每次垃圾回收都是扫描Eden区和From区，将存活对象复制到To区，然后交换From和To区名称引用
  - 下次垃圾回收继续，from到to去的复制逻辑，
  - 当一个对象经过几次新生代垃圾回收，也就是几次从from区到to区，依然存活，那么这个对象就会被**复制到老年代区域**
  - 当老年代区域空间满了，无法进行复制多次存活的对象的时候，会对新生代和老年代的内存空间，进行一次**全量垃圾回收，即Full GC**
  - 根据应用程序的对象存活时间，合理**设置老年代和新生代的空间比例**对JVM垃圾回收的性能有很大影响
  - JVM设置老年代新生代的比例参数是： -XX:NewRatio

![分代回收垃圾](4-Java虚拟机原理.assets/分代回收垃圾.png)





### 六、Java垃圾回收器

- **Serial**串行垃圾回收器
  - jvm早期的垃圾回收器，只有一个线程执行垃圾回收
- **Parallel**并行垃圾回收器
  - 它启动多线程执行垃圾回收
  - JVM运行在多核CPU上，可见性能高于串行
- **Stop the world**
  - 串行和并行来垃圾回收启动后，必须要停止用户线程工作，否则可能导致对象的引用标记错乱，因此垃圾回收过程，在用户视角看来，所有的程序都不再执行，整个世界都停止了
- **CMS**并发垃圾回收器
  - 在垃圾回收的某些阶段，垃圾回收线程和用户线程可以并发运行。此时对用户线程的影响最小
  - Web应用对用户响应时间敏感的场景，适合使用
- **G1**垃圾回收器
  - 将整个堆空间分成多个子区域，然后在这个子区域上各自独立进行垃圾回收
  - 回收过程中，垃圾回收线程和用户线程也是并发运行
  - G1综合各家之长，使用各种场景

![垃圾回收器](4-Java虚拟机原理.assets/垃圾回收器.png)





### 七、JVM配置参数

- **OutOfMemoryError**
  - 表示为堆内存空间不足，可能是JVM分配的内存空间不足让程序正常运行
  - 调整 -Xmx 参数，增大内存空间
- 程序存在**内存泄漏**，如一些对象被放入List或者Map等容器中，这些对象不在使用，但是仍被容器引用，无法进行来及回收，导致内存泄漏
  - 通过jmap命令，查看堆中的对象情况，分析是否有内存泄漏
- **StackOverflowError**
  - 栈空间不足，由于调用方法的层数太多，导致栈帧太多
  - 通过栈压栈信息观察是否存在错误递归调用
  - 调整 -Xss 参数增加栈空间大小
- 程序运行卡顿，部分请求**响应延迟厉害**
  - 通过jstat命令查看垃圾回收器的运行情况，是否存在较长时间的Full Gc
  - 调整垃圾回收器的策略，使垃圾回收器对程序运行的影响最小
- JVM的**即时编译JIT**
  - 由于执行引擎在执行字节码指令的时候，是解释执行的，每一个字节码指令被解释为一个底层的CPU指令
  - 这样的解释效率比较差
  - JVM将频繁执行的代码，编译为底层CPU指令存储起来，后面再次执行，直接执行编译好的指令，不在解释执行，即jit即时编译
  - Web应用程序通常长时间运行，使用JIT可以得到很好的优化效果
  - 通过-server参数打开JIT的C2编译器，进行优化





### 八、Java web程序运行时的执行环境

- 进程，线程，应用，Web容器，java虚拟机，操作系统之间的关系
  - 从JVM角度看，Tomcat和Web应用一样，都是一些java代码，但是Tomcat可以加载执行web代码，而我们的代码不依赖Tomcat
- java开发Web应用，开发完成，编译打包以后得到的是一个**war包**
  - 将war包放入Tomcat的应用程序路径下，启动Tomcat就可以通过HTTP请求访问这个Web应用
- 通过执行**Tomcat的Shell脚本**启动Tomcat，Shell脚本里，其实**启动的是java虚拟机**
  - java org.apache.catalina.startup.Bootstrap "$@" start
  - 所以在Linux操作系统执行Tomcat的Shell启动脚本，启动之后，其实在操作系统里看到的是一个JVM虚拟机进程
- 虚拟机进程启动以后，加载class进来执行，首先加载的就是 **org.apache.catalina.startup.Bootstrap 类**，这个类里面有一个main（） 函数，是整个Tomcat的入口函数，JVM虚拟机会启动一个**主线程**从这个入口函数开始执行
  - 主线程从Bootstrap的main（）函数开始执行，初始化Tomcat的运行环境，这里需要**创建一些线程**，如监听80端口的线程，处理客户端连接请求的线程，执行用户请求的线程，创建线程的代码是Tomcat代码的一部分
  - 初始化运行环境后，Tomcat会**扫描Web程序路径**，扫描到开发的war包后，再加载war包里的类到JVM。
  - 因为Web应用是被Tomcat加载运行的，所以我们称Tomcat为Web容器
  - 如果有外部请求发送到Tomcat，外部程序通过80端口和Tomcat进行HTTP通信，Tomcat会根据war包中的**web.xml配置**，决定这个请求URL应该由那个Servlet处理，然后**Tomcat就会分配一个线程去处理这个请求**
  - 实际上，这个线程执行相应的Servlet代码
- Tomcat启动的时候，启动的是JVM进程，这个进程首先是执行JVM的代码，JVM会加载Tomcat的class执行，并分配一个主线程，这个主线程会从main函数开始执行，在主线程执行过程中，Tomcat的代码还会启动其他的一些线程，包括处理HTTP请求的线程
  - 开发的应用，也是一些class，被Tomcat加载到这个JVM里运行，即使这里有多个应用被加载，也只是加载了一些class，并没有增加JVM进程中的线程数，**web应用本身和线程没有关系**
  - Tomcat会根据HTTP请求的URL执行应用中的代码，这个时候，可以理解成每个请求分配一个线程，每个线程执行的都是我们开发的Web代码
  - 如果Web代码，包含了**创建新线程**的代码，Tomcat的线程在执行代码时，就会创建出新的线程，这些线程也会被操作系统调度运行
  - 如果Tomcat的线程在执行代码的时候，**抛出未处理的异常，那么当前线程就会结束执行**，这时控制台看到的异常信息，其实就是线程堆栈信息，线程会把异常信息以及当前堆栈的方法都打印出来
  - 这个**异常信息，最后还是会被Tomcat捕获**，然后Tomcat给客户端返回一个**500错误**，**单个线程的异常，不影响其他线程执行，也就是不影响其他请求的处理**
  - 但是线程在执行代码的时候，跑出**JVM错误，如OutOfMemoryerror**，这个时候看起来是应用Crash了，实际是**整个进程都无法继续执行了，是进程crash了**，进程内的所有应用都不会被继续执行







## 结束语

文中涉及的知识包括：**Java语言，JVM，操作系统，程序栈，堆，线程栈，线程，Web 容器，Tomcat，线程安全，垃圾回收机制，垃圾回收器，JIT，JVM配置等。**

需要记住的几点：

**1.使用Web容器，实现网络请求访问，本质是Web容器分配线程给请求，完成操作，即应用本身和执行线程没有关系。**

**2.常见的Java垃圾回收器，包含：Serial串行垃圾回收器，Parallel并行垃圾回收器，CMS并发垃圾回收器，G1垃圾回收器。**

**3.分代垃圾回收的时候，是回收堆的对象，将堆内存分为新生代和老年代。新生代内部细分为三个区域，Eden，From，To区，From和To区会相互复制对象，并且复制完成之后更换名字。**




